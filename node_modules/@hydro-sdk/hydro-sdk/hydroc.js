#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = require("assert");
const cp = __importStar(require("child_process"));
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const axios_1 = __importDefault(require("axios"));
const commander_1 = require("commander");
const progress_1 = __importDefault(require("progress"));
const defaultCacheDir = ".hydroc";
class Hydroc {
    constructor({ sdkToolsVersion }) {
        this.sdkTools = [
            "hc2Dart",
            "ts2hc",
            "luac52",
            "swid",
            "build-project",
            "run-project",
        ];
        assert_1.strict(sdkToolsVersion !== undefined && sdkToolsVersion !== "");
        this.cacheDir = `.hydroc${path.sep}${sdkToolsVersion}`;
        this.sdkToolsDir = `${this.cacheDir}${path.sep}sdk-tools`;
        this.sdkToolsVersion = sdkToolsVersion;
    }
    ensureSdkToolsDirectoryExists() {
        if (!fs.existsSync(this.sdkToolsDir)) {
            fs.mkdirSync(this.sdkToolsDir, { recursive: true });
        }
    }
    makeSdkToolPlatformName({ toolName, }) {
        return `${toolName}-${process.platform}-${process.arch}${process.platform == "win32" ? ".exe" : ""}`;
    }
    makeSdkToolPlatformPath({ toolName, }) {
        return `${this.sdkToolsDir}${path.sep}${this.makeSdkToolPlatformName({
            toolName,
        })}`;
    }
    findMissingSdkTools() {
        this.ensureSdkToolsDirectoryExists();
        return this.sdkTools
            .map((x) => !fs.existsSync(`${this.sdkToolsDir}${path.sep}${this.makeSdkToolPlatformName({ toolName: x })}`)
            ? x
            : undefined)
            .filter((x) => x !== undefined);
    }
    downloadMissingSdkTools() {
        return __awaiter(this, void 0, void 0, function* () {
            const missingSdkTools = this.findMissingSdkTools();
            if (missingSdkTools.length > 0) {
                console.log(`Downloading Hydro-SDK tools version ${this.sdkToolsVersion} to ${this.sdkToolsDir}`);
                for (let i = 0; i != missingSdkTools.length; ++i) {
                    const missingSdkTool = missingSdkTools[i];
                    yield new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                        const url = `https://github.com/hydro-sdk/hydro-sdk/releases/download/${this.sdkToolsVersion}/${this.makeSdkToolPlatformName({
                            toolName: missingSdkTool,
                        })}`;
                        const { data, headers } = yield axios_1.default({
                            url,
                            method: "GET",
                            responseType: "stream",
                        });
                        const totalLength = headers["content-length"];
                        const progressBar = new progress_1.default(`    -> ${this.makeSdkToolPlatformName({
                            toolName: missingSdkTool,
                        })} [:bar] :percent :etas`, {
                            width: 40,
                            complete: "=",
                            incomplete: " ",
                            renderThrottle: 1,
                            total: parseInt(totalLength),
                        });
                        const writer = fs.createWriteStream(`${this.sdkToolsDir}${path.sep}${this.makeSdkToolPlatformName({
                            toolName: missingSdkTool,
                        })}`);
                        data.on("data", (chunk) => progressBar.tick(chunk.length));
                        data.on("end", () => resolve(undefined));
                        data.pipe(writer);
                    }));
                }
                yield Promise.all(this.sdkTools.map((x) => __awaiter(this, void 0, void 0, function* () { return yield this.setExecutableBitOnSdkTool({ toolName: x }); })));
            }
            else {
                console.log("All Hydro-SDK tools exist");
            }
        });
    }
    setExecutableBitOnSdkTool({ toolName, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (process.platform == "darwin" || process.platform == "linux") {
                yield new Promise((resolve, reject) => {
                    const chmod = cp.spawn("chmod", [
                        "+x",
                        this.makeSdkToolPlatformPath({ toolName }),
                    ]);
                    chmod.on("exit", (exitCode) => exitCode == 0 ? resolve(undefined) : reject(exitCode));
                }).catch((err) => process.exit(err));
            }
        });
    }
    ts2hc({ entryPoint, moduleName, outDir, profile, logger, }) {
        return cp.spawn(this.makeSdkToolPlatformPath({ toolName: "ts2hc" }), [
            "--cache-dir",
            this.cacheDir,
            "--entry-point",
            entryPoint,
            "--module-name",
            moduleName,
            "--out-dir",
            outDir,
            "--profile",
            profile,
            "--logger",
            logger,
        ], {
            stdio: "inherit",
        });
    }
    buildProject({ project, ts2hc, profile, outDir, }) {
        return cp.spawn(this.makeSdkToolPlatformPath({ toolName: "build-project" }), [
            "--project",
            project,
            "--ts2hc",
            ts2hc,
            "--cache-dir",
            this.cacheDir,
            "--profile",
            profile,
            "--out-dir",
            outDir,
        ], {
            stdio: "inherit",
        });
    }
    runProject({ project, ts2hc }) {
        return cp.spawn(this.makeSdkToolPlatformPath({ toolName: "run-project" }), [
            "--project",
            project,
            "--ts2hc",
            ts2hc,
            "--cache-dir",
            this.cacheDir,
            "--profile",
            "debug",
        ], {
            stdio: "inherit",
        });
    }
}
function readSdkPackage({ directory, }) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return JSON.parse(fs.readFileSync(`${directory}${path.sep}package.json`).toString());
        }
        catch (err) {
            console.error(err);
            return undefined;
        }
    });
}
(() => __awaiter(void 0, void 0, void 0, function* () {
    const sdkPackage = yield readSdkPackage({ directory: __dirname });
    if (sdkPackage === undefined) {
        process.exit(1);
    }
    const program = new commander_1.Command();
    program.version(sdkPackage.version);
    program
        .command("sdk-tools")
        .description("Download tools required by Hydro-SDK into the given cache directory")
        .addOption(new commander_1.Option("--tools-version <version>", "The version of SDK tools to download").default(sdkPackage.version))
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        var _a;
        const hydroc = new Hydroc({
            sdkToolsVersion: (_a = options.toolsVersion) !== null && _a !== void 0 ? _a : sdkPackage.version,
        });
        yield hydroc.downloadMissingSdkTools();
    }));
    program
        .command("ts2hc")
        .description("Compile the Typescript file given by --entry-point and all of its dependencies into a bytecode chunk, written to --out-dir")
        .addOption(new commander_1.Option("--entry-point <entry>", "The file to use as the compilation's entry point").makeOptionMandatory())
        .addOption(new commander_1.Option("--module-name <name>", "The name to use for the output module").makeOptionMandatory())
        .addOption(new commander_1.Option("--out-dir <dir>", "The path to the directory to write the output chunk to").makeOptionMandatory())
        .addOption(new commander_1.Option("--profile <profile>", "The profile to use for compilation").makeOptionMandatory())
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        var _b;
        const hydroc = new Hydroc({
            sdkToolsVersion: (_b = options.toolsVersion) !== null && _b !== void 0 ? _b : sdkPackage.version,
        });
        yield hydroc.downloadMissingSdkTools();
        yield new Promise((resolve, reject) => {
            const ts2hc = hydroc.ts2hc({
                entryPoint: options.entryPoint,
                moduleName: options.moduleName,
                outDir: options.outDir,
                profile: options.profile,
                logger: "stdout",
            });
            ts2hc.on("exit", (exitCode) => exitCode == 0 ? resolve(undefined) : reject(exitCode));
        }).catch((err) => process.exit(err));
    }));
    program
        .command("build")
        .description("Build the project given by --project")
        .addOption(new commander_1.Option("--project <project>", "The project description to use").default("hydro.json"))
        .addOption(new commander_1.Option("--out-dir <out-dir>", "The directory to write build outputs to").default(""))
        .addOption(new commander_1.Option("--profile <profile>", "The build profile to use for all chunks in the project").default("release"))
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        var _c;
        const hydroc = new Hydroc({
            sdkToolsVersion: (_c = options.toolsVersion) !== null && _c !== void 0 ? _c : sdkPackage.version,
        });
        yield hydroc.downloadMissingSdkTools();
        yield new Promise((resolve, reject) => {
            const buildProject = hydroc.buildProject({
                project: options.project,
                profile: options.profile,
                outDir: options.outDir,
                ts2hc: hydroc.makeSdkToolPlatformPath({
                    toolName: "ts2hc",
                }),
            });
            buildProject.on("exit", (exitCode) => exitCode == 0 ? resolve(undefined) : reject(exitCode));
        }).catch((err) => process.exit(err));
    }));
    program
        .command("run")
        .description("Run the project given by --project")
        .addOption(new commander_1.Option("--project <project>", "The project description to use").default("hydro.json"))
        .action((options) => __awaiter(void 0, void 0, void 0, function* () {
        var _d;
        const hydroc = new Hydroc({
            sdkToolsVersion: (_d = options.toolsVersion) !== null && _d !== void 0 ? _d : sdkPackage.version,
        });
        yield hydroc.downloadMissingSdkTools();
        yield new Promise((resolve, reject) => {
            const runProject = hydroc.runProject({
                project: options.project,
                ts2hc: hydroc.makeSdkToolPlatformPath({
                    toolName: "ts2hc",
                }),
            });
            runProject.on("exit", (exitCode) => exitCode == 0 ? resolve(undefined) : reject(exitCode));
        }).catch((err) => process.exit(err));
    }));
    program.parse(process.argv);
}))();
