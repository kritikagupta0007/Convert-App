"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformQualifiedName = exports.transformPropertyAccessExpression = exports.transformElementAccessExpression = exports.transformElementAccessArgument = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const builtins_1 = require("../builtins");
const annotations_1 = require("../utils/annotations");
const lua_ast_1 = require("../utils/lua-ast");
const typescript_1 = require("../utils/typescript");
const enum_1 = require("./enum");
const lua_table_1 = require("./lua-table");
function transformElementAccessArgument(context, node) {
    const index = context.transformExpression(node.argumentExpression);
    const type = context.checker.getTypeAtLocation(node.expression);
    const argumentType = context.checker.getTypeAtLocation(node.argumentExpression);
    if (typescript_1.isNumberType(context, argumentType) && typescript_1.isArrayType(context, type)) {
        return lua_ast_1.createExpressionPlusOne(index);
    }
    return index;
}
exports.transformElementAccessArgument = transformElementAccessArgument;
exports.transformElementAccessExpression = (expression, context) => {
    lua_table_1.validateLuaTableElementAccessExpression(context, expression);
    const constEnumValue = enum_1.tryGetConstEnumValue(context, expression);
    if (constEnumValue) {
        return constEnumValue;
    }
    const argumentType = context.checker.getTypeAtLocation(expression.argumentExpression);
    const type = context.checker.getTypeAtLocation(expression.expression);
    if (typescript_1.isNumberType(context, argumentType) && typescript_1.isStringType(context, type)) {
        return transformStringIndex(context, expression);
    }
    return lua.createTableIndexExpression(context.transformExpression(expression.expression), transformElementAccessArgument(context, expression), expression);
};
exports.transformPropertyAccessExpression = (expression, context) => {
    const constEnumValue = enum_1.tryGetConstEnumValue(context, expression);
    if (constEnumValue) {
        return constEnumValue;
    }
    const luaTableResult = lua_table_1.transformLuaTablePropertyAccessExpression(context, expression);
    if (luaTableResult) {
        return luaTableResult;
    }
    const builtinResult = builtins_1.transformBuiltinPropertyAccessExpression(context, expression);
    if (builtinResult) {
        return builtinResult;
    }
    const property = expression.name.text;
    const type = context.checker.getTypeAtLocation(expression.expression);
    const annotations = annotations_1.getTypeAnnotations(type);
    // Do not output path for member only enums
    if (annotations.has(annotations_1.AnnotationKind.CompileMembersOnly)) {
        if (ts.isPropertyAccessExpression(expression.expression)) {
            // in case of ...x.enum.y transform to ...x.y
            return lua.createTableIndexExpression(context.transformExpression(expression.expression.expression), lua.createStringLiteral(property), expression);
        }
        else {
            return lua.createIdentifier(property, expression);
        }
    }
    const callPath = context.transformExpression(expression.expression);
    return lua.createTableIndexExpression(callPath, lua.createStringLiteral(property), expression);
};
exports.transformQualifiedName = (node, context) => {
    const right = lua.createStringLiteral(node.right.text, node.right);
    const left = context.transformExpression(node.left);
    return lua.createTableIndexExpression(left, right, node);
};
function transformStringIndex(context, expression) {
    const string = context.transformExpression(expression.expression);
    // Translate to string.sub(str, index, index), cache index in case it has side effects.
    if (typescript_1.isExpressionWithEvaluationEffect(expression.argumentExpression)) {
        const indexIdentifier = lua.createIdentifier("____index");
        // string.sub(stringExpression, ____index, ____index)
        const subCall = lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("string"), lua.createStringLiteral("sub")), [string, lua.cloneIdentifier(indexIdentifier), lua.cloneIdentifier(indexIdentifier)], expression);
        // function(____index) string.sub(stringExpression, ____index, ____index)
        const functionExpression = lua.createFunctionExpression(lua.createBlock([lua.createReturnStatement([subCall])]), [lua.cloneIdentifier(indexIdentifier)]);
        // (function(____index) string.sub(stringExpression, ____index, ____index) end)(index + 1)
        const indexPlusOne = lua_ast_1.createExpressionPlusOne(context.transformExpression(expression.argumentExpression));
        return lua.createCallExpression(functionExpression, [indexPlusOne]);
    }
    else {
        const index = context.transformExpression(expression.argumentExpression);
        return lua.createCallExpression(lua.createTableIndexExpression(lua.createIdentifier("string"), lua.createStringLiteral("sub")), [string, lua_ast_1.createExpressionPlusOne(index), lua_ast_1.createExpressionPlusOne(index)], expression);
    }
}
//# sourceMappingURL=access.js.map