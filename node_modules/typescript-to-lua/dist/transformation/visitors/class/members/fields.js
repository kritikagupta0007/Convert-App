"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformClassInstanceFields = void 0;
const ts = require("typescript");
const lua = require("../../../../LuaAST");
const lua_ast_1 = require("../../../utils/lua-ast");
const literal_1 = require("../../literal");
const accessors_1 = require("./accessors");
function transformClassInstanceFields(context, classDeclaration, instanceFields) {
    var _a;
    const statements = [];
    for (const f of instanceFields) {
        // Get identifier
        const fieldName = literal_1.transformPropertyName(context, f.name);
        const value = f.initializer ? context.transformExpression(f.initializer) : undefined;
        // self[fieldName]
        const selfIndex = lua.createTableIndexExpression(lua_ast_1.createSelfIdentifier(), fieldName);
        // self[fieldName] = value
        const assignClassField = lua.createAssignmentStatement(selfIndex, value, f);
        statements.push(assignClassField);
    }
    // TODO: Remove when `useDefineForClassFields` would be `true` by default
    const getOverrides = classDeclaration.members.filter((m) => accessors_1.isGetAccessorOverride(context, m, classDeclaration));
    for (const getter of getOverrides) {
        const getterName = literal_1.transformPropertyName(context, getter.name);
        const resetGetter = lua.createExpressionStatement(lua.createCallExpression(lua.createIdentifier("rawset"), [
            lua_ast_1.createSelfIdentifier(),
            getterName,
            lua.createNilLiteral(),
        ]), (_a = classDeclaration.members.find(ts.isConstructorDeclaration)) !== null && _a !== void 0 ? _a : classDeclaration);
        statements.push(resetGetter);
    }
    return statements;
}
exports.transformClassInstanceFields = transformClassInstanceFields;
//# sourceMappingURL=fields.js.map