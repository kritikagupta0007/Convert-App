"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createConstructorDecorationStatement = void 0;
const lua = require("../../../LuaAST");
const diagnostics_1 = require("../../utils/diagnostics");
const export_1 = require("../../utils/export");
const function_context_1 = require("../../utils/function-context");
const lualib_1 = require("../../utils/lualib");
const identifier_1 = require("../identifier");
function createConstructorDecorationStatement(context, declaration) {
    const className = declaration.name !== undefined
        ? export_1.addExportToIdentifier(context, identifier_1.transformIdentifier(context, declaration.name))
        : lua.createAnonymousIdentifier();
    const decorators = declaration.decorators;
    if (!decorators) {
        return undefined;
    }
    const decoratorExpressions = decorators.map(decorator => {
        const expression = decorator.expression;
        const type = context.checker.getTypeAtLocation(expression);
        const callContext = function_context_1.getFunctionContextType(context, type);
        if (callContext === function_context_1.ContextType.Void) {
            context.diagnostics.push(diagnostics_1.decoratorInvalidContext(decorator));
        }
        return context.transformExpression(expression);
    });
    const decoratorTable = lua.createTableExpression(decoratorExpressions.map(expression => lua.createTableFieldExpression(expression)));
    return lua.createAssignmentStatement(className, lualib_1.transformLuaLibFunction(context, lualib_1.LuaLibFeature.Decorate, undefined, decoratorTable, className));
}
exports.createConstructorDecorationStatement = createConstructorDecorationStatement;
//# sourceMappingURL=decorators.js.map