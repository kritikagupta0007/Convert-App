"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.transformSourceFileNode = void 0;
const ts = require("typescript");
const lua = require("../../LuaAST");
const utils_1 = require("../../utils");
const lua_ast_1 = require("../utils/lua-ast");
const scope_1 = require("../utils/scope");
const typescript_1 = require("../utils/typescript");
exports.transformSourceFileNode = (node, context) => {
    let statements = [];
    if (node.flags & ts.NodeFlags.JsonFile) {
        const [statement] = node.statements;
        if (statement) {
            utils_1.assert(ts.isExpressionStatement(statement));
            statements.push(lua.createReturnStatement([context.transformExpression(statement.expression)]));
        }
        else {
            const errorCall = lua.createCallExpression(lua.createIdentifier("error"), [
                lua.createStringLiteral("Unexpected end of JSON input"),
            ]);
            statements.push(lua.createExpressionStatement(errorCall));
        }
    }
    else {
        scope_1.pushScope(context, scope_1.ScopeType.File);
        statements = scope_1.performHoisting(context, context.transformStatements(node.statements));
        scope_1.popScope(context);
        if (context.isModule) {
            // If export equals was not used. Create the exports table.
            // local ____exports = {}
            if (!typescript_1.hasExportEquals(node)) {
                statements.unshift(lua.createVariableDeclarationStatement(lua_ast_1.createExportsIdentifier(), lua.createTableExpression()));
            }
            // return ____exports
            statements.push(lua.createReturnStatement([lua_ast_1.createExportsIdentifier()]));
        }
    }
    return lua.createBlock(statements, node);
};
//# sourceMappingURL=sourceFile.js.map