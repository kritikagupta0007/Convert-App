"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bundleTranspiledFiles = void 0;
const path = require("path");
const source_map_1 = require("source-map");
const LuaLib_1 = require("../LuaLib");
const LuaPrinter_1 = require("../LuaPrinter");
const utils_1 = require("../utils");
const diagnosticFactories = require("./diagnostics");
const createModulePath = (baseDir, pathToResolve) => LuaPrinter_1.escapeString(utils_1.formatPathToLuaPath(utils_1.trimExtension(path.relative(baseDir, pathToResolve))));
function bundleTranspiledFiles(bundleFile, entryModule, transpiledFiles, program, emitHost) {
    const diagnostics = [];
    const options = program.getCompilerOptions();
    const projectRootDir = options.configFilePath
        ? path.dirname(options.configFilePath)
        : emitHost.getCurrentDirectory();
    // Resolve project settings relative to project file.
    const resolvedEntryModule = path.resolve(projectRootDir, entryModule);
    const resolvedBundleFile = path.resolve(projectRootDir, bundleFile);
    // Resolve source files relative to common source directory.
    const sourceRootDir = program.getCommonSourceDirectory();
    if (!transpiledFiles.some(f => path.resolve(sourceRootDir, f.fileName) === resolvedEntryModule)) {
        return [[diagnosticFactories.couldNotFindBundleEntryPoint(entryModule)], { fileName: bundleFile }];
    }
    // For each file: ["<module path>"] = function() <lua content> end,
    const moduleTableEntries = transpiledFiles.map(f => moduleSourceNode(f, createModulePath(sourceRootDir, f.fileName)));
    // If any of the modules contains a require for lualib_bundle, add it to the module table.
    const lualibRequired = transpiledFiles.some(f => { var _a; return (_a = f.lua) === null || _a === void 0 ? void 0 : _a.includes('require("lualib_bundle")'); });
    if (lualibRequired) {
        moduleTableEntries.push(`["lualib_bundle"] = function() ${LuaLib_1.getLuaLibBundle(emitHost)} end,\n`);
    }
    // Create ____modules table containing all entries from moduleTableEntries
    const moduleTable = createModuleTableNode(moduleTableEntries);
    // Override `require` to read from ____modules table.
    const requireOverride = `
local ____modules = {}
local ____moduleCache = {}
local ____originalRequire = require
local function require(file)
    if ____moduleCache[file] then
        return ____moduleCache[file]
    end
    if ____modules[file] then
        ____moduleCache[file] = ____modules[file]()
        return ____moduleCache[file]
    else
        if ____originalRequire then
            return ____originalRequire(file)
        else
            error("module '" .. file .. "' not found")
        end
    end
end\n`;
    // return require("<entry module path>")
    const entryPoint = `return require(${createModulePath(sourceRootDir, resolvedEntryModule)})\n`;
    const bundleNode = joinSourceChunks([requireOverride, moduleTable, entryPoint]);
    const { code, map } = bundleNode.toStringWithSourceMap();
    return [
        diagnostics,
        {
            fileName: utils_1.normalizeSlashes(resolvedBundleFile),
            lua: code,
            sourceMap: map.toString(),
            sourceMapNode: moduleTable,
        },
    ];
}
exports.bundleTranspiledFiles = bundleTranspiledFiles;
function moduleSourceNode(transpiledFile, modulePath) {
    const tableEntryHead = `[${modulePath}] = function() `;
    const tableEntryTail = "end,\n";
    if (transpiledFile.lua && transpiledFile.sourceMapNode) {
        return joinSourceChunks([tableEntryHead, transpiledFile.sourceMapNode, tableEntryTail]);
    }
    else {
        return joinSourceChunks([tableEntryHead, tableEntryTail]);
    }
}
function createModuleTableNode(fileChunks) {
    const tableHead = "____modules = {\n";
    const tableEnd = "}\n";
    return joinSourceChunks([tableHead, ...fileChunks, tableEnd]);
}
function joinSourceChunks(chunks) {
    return new source_map_1.SourceNode(null, null, null, chunks);
}
//# sourceMappingURL=bundle.js.map